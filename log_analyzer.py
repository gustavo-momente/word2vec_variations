#!/usr/bin/python
__author__ = 'vilelag'

import os
import argparse
import itertools
from multiprocessing import Pool
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.ticker import FuncFormatter
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import cm
from matplotlib import patheffects


def create_parsers():
    #parser for the main program
    parser = argparse.ArgumentParser(description='Create plots from logs generated by compute-accuracy or SE-Test1.py.'
                                                 ' But it is preferable the usage of make_logs.py to get those logs. It'
                                                 ' works with logs of a single draw or averaged logs.')
    parser.add_argument('-se', metavar='<int>', nargs='?', default=0, const=1, type=int,
                        help='Must be present to use logs generated using "SE-Test1.py" (1 : On, else: Off,'
                             ' Default: Off)')
    parser.add_argument('-f', '-folder', metavar='<folder>', default='./Logs/Log0',
                        help='Folder with logs generated by "run_dics.py')
    parser.add_argument('-gdl', metavar='<file>', default='./Logs/out.csv',
                        help='csv generated by "generate_dics.py"')
    parser.add_argument('-o', '-out', metavar='<folder>', default='./Plots',
                        help="Folder where the plots will be generated")
    parser.add_argument('-t', '-threads', metavar='<int>', nargs=1, default=[8], type=int,
                        help='Use <int> threads (default 8)')
    parser.add_argument('-2Ds', metavar='[<int>]', default=0, const=1, type=int, nargs='?',
                        help="If present in the case of only one change, a plot for each class will be generated"
                             " (1=On, else = Off; Default=Off)")
    parser.add_argument('-3D', metavar='[<int>]', default=0, const=1, type=int, nargs='?',
                        help="If present 3D plots will be produced (1=On, else = Off; Default=Off)")
    parser.add_argument('-rot', metavar='[<int>]', default=0, const=1, type=int, nargs='?',
                        help="If present rotations of 3D plots will be produced (1=On, else = Off; Default=Off)")
    parser.add_argument('-cm', '-ca_mean', metavar='<int>', nargs='?', default=0, const=1, type=int,
                        help='Must be present to use logs generated from averaging ca or se logs (1 : On, else: Off,'
                             ' Default: Off)')
    return parser


def create_output_folder(directory):
    if not os.path.exists(directory):
        os.makedirs(directory)


def read_log(log):
    with open(log) as f:
        content = f.read().splitlines()
    file_name = content[0]
    data = dict()
    for i in range(1, len(content)-1, 3):
        kind = content[i][:-1]
        top1 = float(content[i+1].split(" ")[2])

        line3 = content[i+2].split(" ")
        ta = float(line3[2])
        sem = float(line3[8])
        syn = float(line3[14])
        data[kind] = [top1, ta, sem, syn]

    # Adding a plot for the average!
    flag = 0
    mean = []
    for key in data:
        if flag == 0:
            mean = list(data[key])
            flag = 1
        else:
            for i in range(len(mean)):
                mean[i] += data[key][i]
    for i in range(len(mean)):
        mean[i] /= len(data)
    data['Average'] = mean

    ll = content[-1].split(" ")
    dic2 = {'seen': ll[4], 'total': ll[5]}
    return data, dic2


def read_log_ca_mean(log):
    with open(log) as f:
        content = f.read().splitlines()
    data = dict()
    for i in range(1, len(content), 1):
        _split = content[i].split(',')
        kind = _split[0]
        _data = [float(n) for n in _split[1:]]
        data[kind] = _data
    # Adding a plot for the average!
    flag = 0
    mean = []
    for key in data:
        if flag == 0:
            mean = list(data[key])
            flag = 1
        else:
            for i in range(len(mean)):
                mean[i] += data[key][i]

    for i in range(len(mean)):
        mean[i] /= len(data)
    data['Average'] = mean
    return data


def read_se_log(log):
    with open(log) as f:
        content = f.read().splitlines()
    data = dict()
    for case in content[1:]:
        tmp = case.split(',')
        data[tmp[0]] = [float(tmp[1])]
    return data


def read_csv(csv):
    with open(csv) as f:
        content = f.read().splitlines()
    csv_data = dict()
    for i in range(1, len(content)):
        tmp = content[i].split(';')
        name = os.path.splitext(os.path.basename(tmp[0]))[0]
        size = int(tmp[4])
        window = int(tmp[5])
        sample = float(tmp[6])
        hs = int(tmp[7])
        negative = int(tmp[8])
        min_count = int(tmp[10])
        alpha = float(tmp[11])
        cbow = int(tmp[15])
        csv_data[name] = [size, window, sample, hs, negative, min_count, alpha, cbow]

    return csv_data


def check_changes(llist):

    flags = [0 for i in range(len(llist[0]))]
    elem = [llist[0][i] for i in range(len(llist[0]))]

    for w in llist:
        for i in range(len(w)):
            if elem[i] != w[i]:
                flags[i] = 1

    changes = []
    for i in range(len(flags)):
        if flags[i] == 1:
            changes.append(i)

    return changes


def get_possible_values(llist, pos):
    changes = dict()
    for row in llist:
        try:
            if changes[row[pos]] == 1:
                pass
        except KeyError:
            changes[row[pos]] = 1
    changes = sorted(changes.keys())
    return changes


def get_sub_dic(dic, pos, val):
    new_dic = dict()
    for k in sorted(dic):
        if dic[k][pos] == val:
            new_dic[k] = dic[k]
    return new_dic


def plot_gen(c, changes, csv_data, log_data, out, se):
    t_out = out+'/'+names[c[0]]+'/'+names[c[1]]
    create_output_folder(t_out)
    t_changes = []
    for i in changes:
        if i != c[0] and i != c[1]:
            t_changes.append(i)

    all_values = [get_possible_values(csv_data.values(), el) for el in t_changes]
    all_values_comb = []
    if len(all_values) == 1:
        all_values_comb = list(itertools.product(all_values[0]))
    elif len(all_values) == 2:
        all_values_comb = list(itertools.product(all_values[0], all_values[1]))
    elif len(all_values) == 3:
        all_values_comb = list(itertools.product(all_values[0], all_values[1], all_values[2]))
    elif len(all_values) == 4:
        all_values_comb = list(itertools.product(all_values[0], all_values[1], all_values[2], all_values[3]))
    elif len(all_values) == 5:
        all_values_comb = list(itertools.product(all_values[0], all_values[1], all_values[2], all_values[3],
                                                 all_values[4]))
    elif len(all_values) == 6:
        all_values_comb = list(itertools.product(all_values[0], all_values[1], all_values[2], all_values[3],
                                                 all_values[4], all_values[5]))

    #The next loop can be optimized
    count = 0
    for tp in all_values_comb:
        tmp_csv = csv_data
        for i in range(len(tp)):
            tmp_csv = get_sub_dic(tmp_csv, t_changes[i], tp[i])

        plot3d_gen([c[0], c[1]], tmp_csv, log_data, t_out, se, count=str(count)+'_')
        count += 1
    print c


def init_plot_gen(plot_gen_args):
    return plot_gen(*plot_gen_args)


def plot_percent(var, pos=0):
    return '{0:2.1f} %'.format(var)


def plot2d_gen(pos, csv_data, log_data, folder, se, flag=0):
    X = []
    Y = dict()
    for k in sorted(csv_data):
        X.append(csv_data[k][pos])
        for t, data in log_data[k].items():
            try:
                Y[t] = np.append(Y[t], [data], axis=0)
            except KeyError:
                Y[t] = np.array([data])

    x = np.array(X)

    #Joint plot
    plt.figure(figsize=(16, 9))
    # plt.subplot(111)
    num_plots = len(Y.keys())
    markers = itertools.cycle(['o', "v", '^', '<', '>', 's', '*', 'x', 'd'])

    colormap = plt.cm.get_cmap('rainbow')
    plt.gca().set_color_cycle([colormap(i) for i in np.linspace(0, 1, num_plots)])
    for k in sorted(Y):
        y = Y[k][:, 0]
        plt.plot(x, y, label=k, marker=markers.next())

    add_table(csv_data, [pos])
    plt.xlabel(names[pos])
    if se != 0:
        plt.ylabel("Spearman's rho")
        plt.gca().yaxis.set_major_formatter(FuncFormatter(lambda x, pos=0: "{0:.3f} ".format(x)))
    else:
        plt.ylabel('Accuracy TOP1')
        plt.gca().yaxis.set_major_formatter(FuncFormatter(lambda x, pos=0: "{0:.1f} \%".format(x)))

    plt.grid(True)
    lgd = plt.legend(bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0)
    lgd.get_frame().set_alpha(0.4)


    # plt.savefig(folder+'/'+names[pos], bbox_extra_artists=(lgd,), bbox_inches='tight', transparent=False)
    plt.savefig(folder+'/'+names[pos], bbox_inches='tight', transparent=False)
    plt.close()
    
    #Separated Plots
    if flag != 0:
        num_plots = len(Y.keys())
        markers = itertools.cycle(['o', "v", '^', '<', '>', 's', '*', 'x', 'd'])
        colormap = plt.cm.get_cmap('rainbow')
        colors = itertools.cycle([colormap(i) for i in np.linspace(0, 1, num_plots)])

        for k in sorted(Y):
            print k
            y = Y[k][:, 0]
            plt.figure(figsize=(16, 9))
            plt.plot(x, y, label=k, marker=markers.next(), color=colors.next())
            plt.xlabel(names[pos])
            if se != 0:
                plt.ylabel("Spearman's rho")
                plt.gca().yaxis.set_major_formatter(FuncFormatter(lambda x, pos=0: "{0:.3f} ".format(x)))
            else:
                plt.ylabel('Accuracy TOP1')
                plt.gca().yaxis.set_major_formatter(FuncFormatter(lambda x, pos=0: "{0:.1f} \%".format(x)))
            plt.grid(True)
            plt.title(k)
            add_table(csv_data, [pos])
            plt.savefig(folder+'/'+names[pos]+'_'+k+'.png', bbox_inches='tight', transparent=False)
            plt.close()


def plot3d_gen(changes, csv_data, log_data, folder, se, rot=0, flag3D=0, count=''):
    xdic = dict()
    ydic = dict()
    zdic = dict()
    for k in sorted(csv_data):
        t_x = csv_data[k][changes[0]]
        t_y = csv_data[k][changes[1]]

        try:
            xdic[t_x].append(t_x)
        except KeyError:
            xdic[t_x] = [t_x]
        try:
            ydic[t_y].append(t_y)
        except KeyError:
            ydic[t_y] = [t_y]

        for t, data in log_data[k].items():
            try:
                zdic[t][(t_x, t_y)] = data
            except KeyError:
                zdic[t] = {(t_x, t_y): data}
    x = [xdic[i] for i in sorted(xdic)]
    y = [ydic[i] for i in sorted(ydic)]
    x = np.array(x).T
    y = np.array(y)
    z_ = dict()
    z = dict()
    for ty in zdic:
        z_[ty] = []
        for k in sorted(zdic[ty]):
            z_[ty].append(zdic[ty][k][0])
        z[ty] = np.array(z_[ty])
        z[ty] = z[ty].reshape((x.shape[1], x.shape[0])).T

    for k in sorted(z):
        fig = plt.figure(figsize=(16, 9))
        if flag3D == 1:
            ax = fig.add_subplot(211, projection='3d')
            ax.plot_surface(x, y, z[k], rstride=1, cstride=1, cmap=cm.get_cmap('bwr'))
            if se != 0:
                ax.set_zlabel("Spearman's rho")
                plt.gca().zaxis.set_major_formatter(FuncFormatter(lambda x, pos=0: "{0:.3f} ".format(x)))
            else:
                ax.set_zlabel('Accuracy TOP1')
                plt.gca().zaxis.set_major_formatter(FuncFormatter(plot_percent))
        else:
            ax = fig.add_subplot(111)
            if se != 0:
                cax = ax.imshow(z[k], cmap=cm.jet, interpolation='None', origin='lower',
                                extent=[x[0][0], x[0][-1], y[0][0], y[-1][0]], aspect='auto', vmin=-1, vmax=1)
                bar = fig.colorbar(cax, format='%.3f')
                bar.set_label("Spearman's rho")
            else:
                cax = ax.imshow(z[k], cmap=cm.jet, interpolation='None', origin='lower',
                                extent=[x[0][0], x[0][-1], y[0][0], y[-1][0]], aspect='auto', vmin=0, vmax=100)
                bar = fig.colorbar(cax, format='%.1f%%')
                bar.set_label('Accuracy TOP1')

            a1 = len(z[k])
            a2 = len(z[k][0])
            for i in xrange(a1):
                for j in xrange(a2):
                    ax.text(float(j+0.5)/a2, float(i+0.5)/a1, '{0:.3}'.format(z[k][i][j]),
                            size='medium', ha='center', va='center', transform=ax.transAxes,
                            path_effects=[patheffects.withSimplePatchShadow(shadow_rgbFace=(1, 1, 1))])

        plt.title(k)
        plt.xlabel(names[changes[0]])
        plt.ylabel(names[changes[1]])

        plt.gca().yaxis.set_major_formatter(FuncFormatter(lambda x, pos=0: "{0:.1E}".format(x)))
        plt.gca().xaxis.set_major_formatter(FuncFormatter(lambda x, pos=0: "{0:.1E}".format(x)))
        add_table(csv_data, changes)


        if rot == 1 and flag3D == 1 and count == '':
            create_output_folder('{0}/{1}'.format(folder, k))
            for ii in xrange(0, 360, 20):
                ax.view_init(elev=30., azim=ii)
                plt.savefig(folder+'/'+k+'/{}'.format(ii)+names[changes[0]]+'-'+names[changes[1]]+'_'+k+'.png',
                            bbox_inches='tight', transparent=False)
        else:
            plt.savefig(folder+'/'+count+names[changes[0]]+'-'+names[changes[1]]+'_'+k, bbox_inches='tight',
                        transparent=False)
        plt.close()


def add_table(csv_data, changes):
    plt.rc('text', usetex=True)
    table = '\\begin{tabular}{|'+''.join(['c |'*len(names)]) + '} \\hline '
    table += ' & '.join(['\\textbf{{{}}}'.format(n) for n in names]) + '\\\\ \hline '
    vals = csv_data.itervalues().next()
    vals = [str(i) for i in vals]
    for i in changes:
        vals[i] = '--'
    table += ' & '.join(vals) + '\\\\ \hline '
    table += '\\end{tabular}'
    plt.figtext(0.3, -0.02, table)


def main():
    parser = create_parsers()
    args = vars(parser.parse_args())
    se = args['se']
    gdl = args['gdl']
    out = args['o'].rstrip('/')
    flag3D = args['3D']
    flag2D = args['2Ds']
    rot = args['rot']
    folder = args['f'].rstrip('/')
    threads = args['t'][0]
    cm = args['cm']

    create_output_folder(out)
    csv_data = read_csv(gdl)

    log_data = dict()
    log_list = csv_data.keys()

    for log in log_list:
        try:
            if se == 0:
                if cm == 0:
                    log_data[log], trash = read_log(folder+'/'+log+'.log')
                else:
                    log_data[log] = read_log_ca_mean(folder+'/'+log+'.log')
            else:
                n = int(log.split('_')[-1].rstrip('.bin'))
                log_data[log] = read_se_log(folder+'/SE-2012/{}/log.csv'.format(n))
        except:
            print "Couldn't find {0}.log\n".format(log)
            log_data.pop(log, None)
            csv_data.pop(log, None)
    changes = check_changes(csv_data.values())

    if len(changes) == 1:
        plot2d_gen(changes[0], csv_data, log_data, out, se, flag=flag2D)
    elif len(changes) == 2:
        plot3d_gen(changes, csv_data, log_data, out, se, rot=rot, flag3D=flag3D)
    else:
        combinations = [i for i in itertools.combinations(changes, 2)]
        pool = Pool(threads)
        pool.map(init_plot_gen, itertools.izip(combinations, itertools.repeat(changes), itertools.repeat(csv_data),
                                               itertools.repeat(log_data), itertools.repeat(out), itertools.repeat(se)))


names = ['size', 'window', 'sample', 'hs', 'negative', 'min-count', 'alpha', 'cbow']
main()